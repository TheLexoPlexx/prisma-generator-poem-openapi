import { generatorHandler } from '@prisma/generator-helper';
import { DMMF, GeneratorOptions } from '@prisma/generator-helper';
import { parseEnvValue } from '@prisma/internals';
import { promises } from 'fs';
import { join } from 'path';

const { mkdir, writeFile } = promises;

generatorHandler({
  onManifest: () => ({
    defaultOutput: './poem',
    prettyName: 'Rust Poem OpenAPI',
  }),
  onGenerate: generate,
});


const default_filename = "prisma_openapi.rs"
const api_name = "Api"

const autoGeneratedComment = `// ------------------------------------------------------
// Generated with github.com/thelexoplexx/prisma-generator-poem-openapi
// Do not edit manually.
// ------------------------------------------------------`

const imports = `use chrono::NaiveDateTime;
use poem::{web::Data, Result};
use poem_openapi::{payload::Json, Object, OpenApi};
use sqlx::PgPool;`

const spaces = "    "

async function generate(options: GeneratorOptions) {
  const { output, config } = options.generator;
  const out_dir = parseEnvValue(output!);
  const file_name = config.outputName || default_filename;

  try {
    await mkdir(out_dir, { recursive: true });

    // for debugging dmmf schema
    // await writeFile('./test.json', JSON.stringify(options.dmmf.datamodel));

    const out_rust = generate_poem_openapi(
      options.dmmf
    )

    await writeFile(join(out_dir, file_name), out_rust);
  } catch (e) {
    console.error('Error: unable to write files for Prisma DBML Generator');
    throw e;
  }
}

function findType(type: String): String {
  switch (type) {
    case "Int":
      return "i32"
    case "DateTime":
      return "NaiveDateTime"
    default:
      return type
  }
}

function generate_poem_openapi(
  dmmf: DMMF.Document,
): string {

  let structs: String[] = [];

  dmmf.datamodel.models.forEach(model => {
    structs.push("#[derive(Object)]")
    structs.push(`pub struct ${model.name} {`)
    model.fields.forEach(field => {

      if (dmmf.datamodel.models.filter(m => m.name == field.type).length == 0) {
        let type = findType(field.type)

        if (field.isList) {
          type = "Option<Vec<" + type + ">>"
        }

        if (!field.isRequired) {
          type = "Option<" + type + ">"
        }

        structs.push(spaces + (field.dbName || field.name) + ": " + type + ",")

      } else {
        // this is a model, skip
      }
    });
    structs.push(`}\n`)
  })

  let api: String[] = [];
  api.push("pub struct " + api_name + ";\n")
  api.push("#[OpenApi]")
  api.push("impl " + api_name + " {")
  dmmf.datamodel.models.forEach(model => {

    let dbname = model.dbName || model.name

    api.push(`
    #[oai(path = \"/${dbname.toLowerCase()}\", method = \"get\")]
    async fn get_${dbname.toLowerCase()}(&self, pool: Data<&PgPool>) -> Result<Json<Vec<${model.name}>>> {
        let get = sqlx::query_as!(${model.name}, \"SELECT * FROM \\\"${dbname}\\\"\")
           .fetch_all(pool.0)
           .await
           .expect(\"Failed to get ${dbname}\");
        Ok(Json(get))
    }`)

    let fields = model.fields.map(f => f.name).join(", ")
    let values = model.fields.map(f => "$" + f.name).join(", ")

    // api.push(`
    // #[oai(path = \"/${dbname.toLowerCase()}\", method = \"post\")]
    // async fn post_${dbname.toLowerCase()}(&self, pool: Data<&PgPool>) -> Result<Json<Vec<${model.name}>>> {
    //     let get = sqlx::query_as!(${model.name}, \"INSERT INTO \\\"${dbname}\\\"\ (${fields}) VALUES (${values}) RETURNING *\")
    //        .fetch_all(pool.0)
    //        .await
    //        .expect(\"Failed to get ${dbname}\");
    //     Ok(Json(get))
    // }`)
  })
  api.push("}\n")

  return [
    autoGeneratedComment,
    imports,
    structs.join("\n"),
    api.join("\n")
  ].join('\n\n');
}